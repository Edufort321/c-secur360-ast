const { Client } = require('pg');

// Configuration de connexion directe √† PostgreSQL
const client = new Client({
  host: 'aws-0-ca-central-1.pooler.supabase.com',
  port: 6543,
  user: 'postgres.nzjjgcccxlqhbtpitmpo',
  password: '321MdlTamara!$',
  database: 'postgres',
  ssl: {
    rejectUnauthorized: false
  }
});

async function analyzeAndFix() {
  try {
    console.log('üîå Connexion √† la base de donn√©es...');
    await client.connect();
    console.log('‚úÖ Connect√© √† Supabase PostgreSQL');

    // 1. Analyser la structure de la table users existante
    console.log('\nüìä Analyse de la table users existante...');
    
    const userTableInfo = await client.query(`
      SELECT column_name, data_type, is_nullable
      FROM information_schema.columns 
      WHERE table_name = 'users' 
      ORDER BY ordinal_position
    `);
    
    console.log('üìã Structure actuelle de la table users:');
    userTableInfo.rows.forEach(row => {
      console.log(`  - ${row.column_name}: ${row.data_type} ${row.is_nullable === 'YES' ? '(nullable)' : '(not null)'}`);
    });

    // 2. V√©rifier le type de l'ID
    const idInfo = userTableInfo.rows.find(row => row.column_name === 'id');
    console.log(`\nüîç Type de l'ID users: ${idInfo ? idInfo.data_type : 'INTROUVABLE'}`);

    // 3. Ajouter les colonnes manquantes une par une
    const columnsToAdd = [
      { name: 'tenant_id', type: 'VARCHAR(100)', nullable: true },
      { name: 'totp_secret', type: 'TEXT', nullable: true },
      { name: 'totp_enabled', type: 'BOOLEAN', nullable: false, default: 'false' },
      { name: 'totp_backup_codes', type: 'TEXT[]', nullable: true },
      { name: 'first_login', type: 'BOOLEAN', nullable: false, default: 'true' },
      { name: 'last_login_at', type: 'TIMESTAMP WITH TIME ZONE', nullable: true },
      { name: 'failed_attempts', type: 'INTEGER', nullable: false, default: '0' },
      { name: 'locked_until', type: 'TIMESTAMP WITH TIME ZONE', nullable: true },
      { name: 'profile', type: 'JSONB', nullable: true },
      { name: 'mfa_required', type: 'BOOLEAN', nullable: true, default: 'true' },
      { name: 'qr_enrolled', type: 'BOOLEAN', nullable: true, default: 'false' },
      { name: 'last_mfa_at', type: 'TIMESTAMP WITH TIME ZONE', nullable: true },
      { name: 'mobile_only', type: 'BOOLEAN', nullable: true, default: 'false' },
      { name: 'can_export', type: 'BOOLEAN', nullable: true, default: 'true' },
      { name: 'invitation_sent_at', type: 'TIMESTAMP WITH TIME ZONE', nullable: true },
      { name: 'invitation_token', type: 'VARCHAR(100)', nullable: true },
      { name: 'activated_at', type: 'TIMESTAMP WITH TIME ZONE', nullable: true },
      { name: 'is_active', type: 'BOOLEAN', nullable: true, default: 'true' }
    ];

    console.log('\nüîß Ajout des colonnes manquantes √† la table users...');
    
    for (const column of columnsToAdd) {
      try {
        // V√©rifier si la colonne existe d√©j√†
        const existsCheck = await client.query(`
          SELECT 1 FROM information_schema.columns 
          WHERE table_name = 'users' AND column_name = $1
        `, [column.name]);
        
        if (existsCheck.rows.length === 0) {
          let alterQuery = `ALTER TABLE users ADD COLUMN ${column.name} ${column.type}`;
          
          if (!column.nullable) {
            alterQuery += ` NOT NULL`;
          }
          
          if (column.default) {
            alterQuery += ` DEFAULT ${column.default}`;
          }
          
          await client.query(alterQuery);
          console.log(`  ‚úÖ Colonne '${column.name}' ajout√©e`);
        } else {
          console.log(`  ‚ö™ Colonne '${column.name}' existe d√©j√†`);
        }
      } catch (err) {
        console.error(`  ‚ùå Erreur pour colonne '${column.name}':`, err.message);
      }
    }

    // 4. Cr√©er les tables RBAC avec les bons types
    console.log('\nüèóÔ∏è Cr√©ation des tables RBAC...');
    
    const userIdType = idInfo ? idInfo.data_type : 'uuid';
    console.log(`üìù Utilisation du type ${userIdType} pour les cl√©s √©trang√®res`);

    // Table roles
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS roles (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          key VARCHAR(50) UNIQUE NOT NULL,
          name VARCHAR(100) NOT NULL,
          description TEXT,
          is_system BOOLEAN DEFAULT false,
          color VARCHAR(7) DEFAULT '#3b82f6',
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
      `);
      console.log('  ‚úÖ Table roles cr√©√©e');
    } catch (err) {
      console.log(`  ‚ö™ Table roles: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
    }

    // Table permissions
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS permissions (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          key VARCHAR(100) UNIQUE NOT NULL,
          module VARCHAR(50) NOT NULL,
          action VARCHAR(50) NOT NULL,
          name VARCHAR(100) NOT NULL,
          description TEXT,
          is_dangerous BOOLEAN DEFAULT false,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
      `);
      console.log('  ‚úÖ Table permissions cr√©√©e');
    } catch (err) {
      console.log(`  ‚ö™ Table permissions: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
    }

    // Table role_permissions
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS role_permissions (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
          permission_id UUID NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
          scope_default VARCHAR(20) DEFAULT 'own',
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          UNIQUE(role_id, permission_id)
        )
      `);
      console.log('  ‚úÖ Table role_permissions cr√©√©e');
    } catch (err) {
      console.log(`  ‚ö™ Table role_permissions: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
    }

    // Table user_roles avec le bon type pour user_id
    try {
      const userIdColumnType = userIdType === 'uuid' ? 'UUID' : 'TEXT';
      await client.query(`
        CREATE TABLE IF NOT EXISTS user_roles (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          user_id ${userIdColumnType} NOT NULL REFERENCES users(id) ON DELETE CASCADE,
          role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
          scope_type VARCHAR(20) CHECK (scope_type IN ('global', 'client', 'site', 'project')),
          scope_id UUID,
          scope_name VARCHAR(200),
          assigned_by ${userIdColumnType} REFERENCES users(id),
          assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          expires_at TIMESTAMP WITH TIME ZONE,
          is_active BOOLEAN DEFAULT true,
          notes TEXT,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          UNIQUE(user_id, role_id, scope_type, scope_id)
        )
      `);
      console.log('  ‚úÖ Table user_roles cr√©√©e');
    } catch (err) {
      console.log(`  ‚ö™ Table user_roles: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
    }

    // 5. Cr√©er les tables inventaire
    console.log('\nüì¶ Cr√©ation des tables inventaire...');

    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS inv_items (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          client_id UUID NOT NULL,
          name TEXT NOT NULL,
          sku TEXT,
          uom TEXT DEFAULT 'UN',
          min_qty NUMERIC DEFAULT 0,
          max_qty NUMERIC,
          reorder_point NUMERIC,
          safety_stock NUMERIC DEFAULT 0,
          default_location_id UUID,
          dimensions JSONB,
          images JSONB DEFAULT '[]'::jsonb,
          serializable BOOLEAN DEFAULT false,
          sellable BOOLEAN DEFAULT false,
          active BOOLEAN DEFAULT true,
          description TEXT,
          category TEXT,
          tags JSONB DEFAULT '[]'::jsonb,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
      `);
      console.log('  ‚úÖ Table inv_items cr√©√©e');
    } catch (err) {
      console.log(`  ‚ö™ Table inv_items: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
    }

    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS inv_locations (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          client_id UUID NOT NULL,
          site_id UUID NOT NULL,
          name TEXT NOT NULL,
          code TEXT,
          parent_location_id UUID REFERENCES inv_locations(id),
          location_type TEXT DEFAULT 'storage',
          capacity NUMERIC,
          temperature_controlled BOOLEAN DEFAULT false,
          outdoor BOOLEAN DEFAULT false,
          description TEXT,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
      `);
      console.log('  ‚úÖ Table inv_locations cr√©√©e');
    } catch (err) {
      console.log(`  ‚ö™ Table inv_locations: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
    }

    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS inv_stock (
          item_id UUID NOT NULL REFERENCES inv_items(id) ON DELETE CASCADE,
          location_id UUID NOT NULL REFERENCES inv_locations(id) ON DELETE CASCADE,
          on_hand NUMERIC DEFAULT 0,
          reserved NUMERIC DEFAULT 0,
          available NUMERIC GENERATED ALWAYS AS (on_hand - reserved) STORED,
          last_counted_at TIMESTAMP WITH TIME ZONE,
          last_updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          PRIMARY KEY (item_id, location_id)
        )
      `);
      console.log('  ‚úÖ Table inv_stock cr√©√©e');
    } catch (err) {
      console.log(`  ‚ö™ Table inv_stock: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
    }

    // 6. Ins√©rer les donn√©es de base
    console.log('\nüìã Insertion des donn√©es initiales...');

    try {
      await client.query(`
        INSERT INTO roles (key, name, description, is_system, color) VALUES
          ('owner', 'Owner / Org Admin', 'Acc√®s complet √† la plateforme', true, '#dc2626'),
          ('client_admin', 'Client Admin', 'Administration compl√®te du client', true, '#ea580c'),
          ('site_manager', 'Gestionnaire de site', 'Gestion des sites assign√©s', true, '#d97706'),
          ('worker', 'Travailleur / Technicien', 'Acc√®s mobile de base', true, '#059669'),
          ('guest', 'Invit√© / Externe', 'Acc√®s lecture limit√©e', true, '#6b7280')
        ON CONFLICT (key) DO NOTHING
      `);
      console.log('  ‚úÖ 5 r√¥les de base ins√©r√©s');
    } catch (err) {
      console.error('  ‚ùå Erreur insertion r√¥les:', err.message);
    }

    try {
      await client.query(`
        INSERT INTO permissions (key, module, action, name, description, is_dangerous) VALUES
          ('planning.view', 'planning', 'view', 'Voir la planification', 'Consulter les plannings', false),
          ('timesheets.view_own', 'timesheets', 'view', 'Voir ses propres feuilles', 'Consulter ses heures', false),
          ('timesheets.create', 'timesheets', 'create', 'Saisir les heures', 'Cr√©er des entr√©es de temps', false),
          ('inventory.view', 'inventory', 'view', 'Voir inventaire', 'Consulter articles et stocks', false),
          ('inventory.scan', 'inventory', 'scan', 'Scanner QR codes', 'Utiliser scanner mobile', false),
          ('users.view', 'users', 'view', 'Voir utilisateurs', 'Consulter liste utilisateurs', false)
        ON CONFLICT (key) DO NOTHING
      `);
      console.log('  ‚úÖ 6 permissions de base ins√©r√©es');
    } catch (err) {
      console.error('  ‚ùå Erreur insertion permissions:', err.message);
    }

    // 7. Cr√©er les indexes
    console.log('\nüìä Cr√©ation des indexes...');

    const indexes = [
      'CREATE INDEX IF NOT EXISTS idx_users_tenant_id ON users(tenant_id)',
      'CREATE INDEX IF NOT EXISTS idx_roles_key ON roles(key)',
      'CREATE INDEX IF NOT EXISTS idx_permissions_key ON permissions(key)',
      'CREATE INDEX IF NOT EXISTS idx_user_roles_user_id ON user_roles(user_id)',
      'CREATE INDEX IF NOT EXISTS idx_inv_items_client_id ON inv_items(client_id)',
      'CREATE INDEX IF NOT EXISTS idx_inv_items_active ON inv_items(active) WHERE active = true'
    ];

    for (const indexQuery of indexes) {
      try {
        await client.query(indexQuery);
        console.log(`  ‚úÖ Index cr√©√©: ${indexQuery.match(/idx_\w+/)[0]}`);
      } catch (err) {
        console.log(`  ‚ö™ Index: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
      }
    }

    // 8. V√©rifier les r√©sultats
    console.log('\nüîç V√©rification finale...');
    
    const tableCheck = await client.query(`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_name IN ('roles', 'permissions', 'user_roles', 'inv_items', 'inv_locations', 'inv_stock')
      ORDER BY table_name
    `);
    
    console.log('üìã Tables cr√©√©es avec succ√®s:');
    tableCheck.rows.forEach(row => {
      console.log(`  ‚úÖ ${row.table_name}`);
    });

    const rolesCount = await client.query('SELECT COUNT(*) FROM roles');
    const permissionsCount = await client.query('SELECT COUNT(*) FROM permissions');
    
    console.log(`\nüìä Donn√©es ins√©r√©es:`);
    console.log(`  - ${rolesCount.rows[0].count} r√¥les`);
    console.log(`  - ${permissionsCount.rows[0].count} permissions`);

    console.log('\nüéâ MIGRATION TERMIN√âE AVEC SUCC√àS!');
    console.log('üîê Syst√®me RBAC op√©rationnel');
    console.log('üì¶ Base inventaire QR-First pr√™te'); 
    console.log('‚è∞ Foundation ERP √©tablie');

  } catch (error) {
    console.error('üí• Erreur g√©n√©rale:', error);
  } finally {
    await client.end();
    console.log('üîå Connexion ferm√©e');
  }
}

// Ex√©cuter la migration
analyzeAndFix();