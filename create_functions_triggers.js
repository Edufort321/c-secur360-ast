const { Client } = require('pg');

const client = new Client({
  host: 'aws-0-ca-central-1.pooler.supabase.com',
  port: 6543,
  user: 'postgres.nzjjgcccxlqhbtpitmpo',
  password: '321MdlTamara!$',
  database: 'postgres',
  ssl: {
    rejectUnauthorized: false
  }
});

async function createFunctionsAndTriggers() {
  try {
    console.log('üîå Connexion √† la base de donn√©es...');
    await client.connect();
    console.log('‚úÖ Connect√© √† Supabase PostgreSQL');

    console.log('\nüîß Cr√©ation des fonctions utilitaires...');

    // 1. Fonction pour calcul overtime
    try {
      await client.query(`
        CREATE OR REPLACE FUNCTION calculate_overtime_hours(
          p_user_id TEXT,
          p_week_start DATE
        ) RETURNS DECIMAL(8,2) AS $$
        DECLARE
          total_regular_hours DECIMAL(8,2);
          overtime_threshold INTEGER;
          overtime_hours DECIMAL(8,2) := 0;
        BEGIN
          -- R√©cup√©rer seuil overtime pour cet utilisateur
          SELECT overtime_threshold_hours INTO overtime_threshold
          FROM user_profile_payroll 
          WHERE user_id = p_user_id;
          
          IF overtime_threshold IS NULL THEN
            overtime_threshold := 40; -- D√©faut 40h/semaine
          END IF;
          
          -- Calculer total heures r√©guli√®res cette semaine
          SELECT COALESCE(SUM(total_hours), 0) INTO total_regular_hours
          FROM timesheet_entries te
          JOIN timesheets ts ON ts.id = te.timesheet_id
          WHERE te.user_id = p_user_id
          AND te.work_date >= p_week_start 
          AND te.work_date < p_week_start + INTERVAL '7 days'
          AND te.activity_type = 'normal';
          
          -- Calculer overtime si d√©passe seuil
          IF total_regular_hours > overtime_threshold THEN
            overtime_hours := total_regular_hours - overtime_threshold;
          END IF;
          
          RETURN overtime_hours;
        END;
        $$ LANGUAGE plpgsql;
      `);
      console.log('  ‚úÖ Fonction calculate_overtime_hours cr√©√©e');
    } catch (err) {
      console.error('  ‚ùå Erreur fonction overtime:', err.message);
    }

    // 2. Fonction pour application per diem automatique
    try {
      await client.query(`
        CREATE OR REPLACE FUNCTION apply_per_diem_rules(
          p_timesheet_entry_id UUID
        ) RETURNS VOID AS $$
        DECLARE
          entry_rec timesheet_entries%ROWTYPE;
          rule_rec per_diem_rules%ROWTYPE;
          distance_km INTEGER;
          hours_worked DECIMAL(8,2);
        BEGIN
          -- R√©cup√©rer entr√©e timesheet
          SELECT * INTO entry_rec FROM timesheet_entries WHERE id = p_timesheet_entry_id;
          
          IF NOT FOUND THEN RETURN; END IF;
          
          -- Parcourir r√®gles per diem actives pour ce client
          FOR rule_rec IN 
            SELECT * FROM per_diem_rules 
            WHERE client_id = entry_rec.client_id 
            AND is_active = true
            AND (effective_until IS NULL OR effective_until >= entry_rec.work_date)
          LOOP
            -- √âvaluer conditions
            distance_km := COALESCE(entry_rec.mileage_km, 0);
            hours_worked := COALESCE(entry_rec.total_hours, 0);
            
            -- Condition: > distance min ET > heures min = per diem
            IF (rule_rec.conditions->>'min_distance_km')::INTEGER <= distance_km 
            AND (rule_rec.conditions->>'min_hours')::DECIMAL <= hours_worked THEN
              
              -- Log per diem (table √† cr√©er)
              INSERT INTO per_diem_logs (
                user_id, timesheet_entry_id, rule_id, 
                work_date, amount, auto_applied
              ) VALUES (
                entry_rec.user_id, p_timesheet_entry_id, rule_rec.id,
                entry_rec.work_date, rule_rec.daily_amount, true
              ) ON CONFLICT DO NOTHING;
              
            END IF;
          END LOOP;
        END;
        $$ LANGUAGE plpgsql;
      `);
      console.log('  ‚úÖ Fonction apply_per_diem_rules cr√©√©e');
    } catch (err) {
      console.error('  ‚ùå Erreur fonction per diem:', err.message);
    }

    // 3. Fonction updated_at automatique
    try {
      await client.query(`
        CREATE OR REPLACE FUNCTION update_updated_at_column()
        RETURNS TRIGGER AS $$
        BEGIN
          NEW.updated_at = NOW();
          RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
      `);
      console.log('  ‚úÖ Fonction update_updated_at_column cr√©√©e');
    } catch (err) {
      console.error('  ‚ùå Erreur fonction updated_at:', err.message);
    }

    // 4. Fonction pour v√©rifier permissions utilisateur
    try {
      await client.query(`
        CREATE OR REPLACE FUNCTION user_has_permission(
          p_user_id TEXT,
          p_permission_key TEXT,
          p_scope_type TEXT DEFAULT 'global',
          p_scope_id UUID DEFAULT NULL
        ) RETURNS BOOLEAN AS $$
        DECLARE
          has_permission BOOLEAN := FALSE;
        BEGIN
          -- V√©rifier via les r√¥les
          SELECT EXISTS (
            SELECT 1
            FROM user_roles ur
            JOIN role_permissions rp ON rp.role_id = ur.role_id
            JOIN permissions p ON p.id = rp.permission_id
            WHERE ur.user_id = p_user_id
            AND ur.is_active = true
            AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
            AND p.key = p_permission_key
            AND (
              ur.scope_type = 'global' OR
              (ur.scope_type = p_scope_type AND ur.scope_id = p_scope_id) OR
              (rp.scope_default = 'global')
            )
          ) INTO has_permission;
          
          RETURN has_permission;
        END;
        $$ LANGUAGE plpgsql SECURITY DEFINER;
      `);
      console.log('  ‚úÖ Fonction user_has_permission cr√©√©e');
    } catch (err) {
      console.error('  ‚ùå Erreur fonction permissions:', err.message);
    }

    // 5. Cr√©er la table per_diem_logs si manquante
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS per_diem_logs (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
          timesheet_entry_id UUID REFERENCES timesheet_entries(id) ON DELETE CASCADE,
          rule_id UUID NOT NULL REFERENCES per_diem_rules(id),
          
          work_date DATE NOT NULL,
          amount DECIMAL(8,2) NOT NULL,
          auto_applied BOOLEAN DEFAULT true,
          
          notes TEXT,
          
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
          
          UNIQUE(user_id, work_date, rule_id)
        )
      `);
      console.log('  ‚úÖ Table per_diem_logs cr√©√©e');
    } catch (err) {
      console.log(`  ‚ö™ per_diem_logs: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
    }

    console.log('\nüîÑ Cr√©ation des triggers automatiques...');

    // 6. Triggers pour updated_at sur toutes les tables appropri√©es
    const tablesWithUpdatedAt = [
      'user_profile_payroll', 'vehicles', 'timesheets', 'timesheet_entries',
      'expenses', 'client_billing_configs', 'planned_assignments'
    ];

    for (const tableName of tablesWithUpdatedAt) {
      try {
        await client.query(`
          DROP TRIGGER IF EXISTS update_${tableName}_updated_at ON ${tableName};
          CREATE TRIGGER update_${tableName}_updated_at 
            BEFORE UPDATE ON ${tableName} 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        `);
        console.log(`  ‚úÖ Trigger updated_at cr√©√© pour ${tableName}`);
      } catch (err) {
        console.error(`  ‚ùå Erreur trigger ${tableName}:`, err.message);
      }
    }

    // 7. Trigger pour application per diem automatique
    try {
      await client.query(`
        CREATE OR REPLACE FUNCTION trigger_apply_per_diem()
        RETURNS TRIGGER AS $$
        BEGIN
          -- Appliquer per diem seulement si nouvelle entr√©e ou changements significatifs
          IF TG_OP = 'INSERT' OR 
             (TG_OP = 'UPDATE' AND (
               OLD.client_id IS DISTINCT FROM NEW.client_id OR
               OLD.mileage_km IS DISTINCT FROM NEW.mileage_km OR
               OLD.total_hours IS DISTINCT FROM NEW.total_hours
             )) THEN
            
            PERFORM apply_per_diem_rules(NEW.id);
          END IF;
          
          RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;

        DROP TRIGGER IF EXISTS trigger_timesheet_entry_per_diem ON timesheet_entries;
        CREATE TRIGGER trigger_timesheet_entry_per_diem
          AFTER INSERT OR UPDATE ON timesheet_entries
          FOR EACH ROW EXECUTE FUNCTION trigger_apply_per_diem();
      `);
      console.log('  ‚úÖ Trigger per diem automatique cr√©√©');
    } catch (err) {
      console.error('  ‚ùå Erreur trigger per diem:', err.message);
    }

    // 8. Cr√©er des fonctions pour inventaire
    try {
      await client.query(`
        CREATE OR REPLACE FUNCTION update_stock_after_transaction()
        RETURNS TRIGGER AS $$
        BEGIN
          -- Mettre √† jour le stock √† la localisation
          INSERT INTO inv_stock (item_id, location_id, on_hand, last_updated_at)
          VALUES (NEW.item_id, NEW.location_id, NEW.delta, NOW())
          ON CONFLICT (item_id, location_id)
          DO UPDATE SET 
            on_hand = inv_stock.on_hand + NEW.delta,
            last_updated_at = NOW();
          
          -- Si transfert, d√©duire du stock source
          IF NEW.reason = 'transfer' AND NEW.location_from_id IS NOT NULL THEN
            INSERT INTO inv_stock (item_id, location_id, on_hand, last_updated_at)
            VALUES (NEW.item_id, NEW.location_from_id, -NEW.delta, NOW())
            ON CONFLICT (item_id, location_id)
            DO UPDATE SET 
              on_hand = inv_stock.on_hand - NEW.delta,
              last_updated_at = NOW();
          END IF;
          
          RETURN NEW;
        END;
        $$ LANGUAGE plpgsql;
      `);
      console.log('  ‚úÖ Fonction update_stock_after_transaction cr√©√©e');
    } catch (err) {
      console.error('  ‚ùå Erreur fonction stock:', err.message);
    }

    // 9. Cr√©er table transactions inventaire si manquante
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS inv_transactions (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          client_id UUID NOT NULL,
          site_id UUID,
          
          -- Article concern√©
          item_id UUID NOT NULL REFERENCES inv_items(id) ON DELETE RESTRICT,
          instance_id UUID,
          
          -- Mouvement
          location_id UUID REFERENCES inv_locations(id) ON DELETE SET NULL,
          location_from_id UUID REFERENCES inv_locations(id) ON DELETE SET NULL,
          delta NUMERIC NOT NULL,
          
          -- Raison du mouvement
          reason TEXT NOT NULL CHECK (reason IN ('receipt','issue','adjust','transfer','sale','return')),
          
          -- Contexte projet/t√¢che
          project_id UUID,
          task_id UUID,
          billing_code TEXT,
          
          -- Tra√ßabilit√©
          user_id TEXT REFERENCES users(id),
          photo_url TEXT,
          note TEXT,
          
          -- R√©f√©rence externe
          reference_type TEXT,
          reference_id UUID,
          
          created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
      `);
      
      // Trigger pour mise √† jour stock automatique
      await client.query(`
        DROP TRIGGER IF EXISTS trigger_update_stock ON inv_transactions;
        CREATE TRIGGER trigger_update_stock 
          AFTER INSERT ON inv_transactions 
          FOR EACH ROW EXECUTE FUNCTION update_stock_after_transaction();
      `);
      console.log('  ‚úÖ Table inv_transactions et trigger stock cr√©√©s');
    } catch (err) {
      console.log(`  ‚ö™ inv_transactions: ${err.message.includes('already exists') ? 'existe d√©j√†' : err.message}`);
    }

    // 10. Enable Row Level Security sur toutes les nouvelles tables
    console.log('\nüîí Activation Row Level Security...');

    const tablesForRLS = [
      'user_profile_payroll', 'vehicles', 'timesheets', 'timesheet_entries',
      'per_diem_rules', 'per_diem_logs', 'expenses', 'client_billing_configs',
      'vehicle_assignments', 'vehicle_logs', 'planned_assignments', 'inv_transactions'
    ];

    for (const tableName of tablesForRLS) {
      try {
        await client.query(`ALTER TABLE ${tableName} ENABLE ROW LEVEL SECURITY;`);
        console.log(`  ‚úÖ RLS activ√© pour ${tableName}`);
      } catch (err) {
        console.log(`  ‚ö™ RLS ${tableName}: ${err.message.includes('already has') ? 'd√©j√† activ√©' : err.message}`);
      }
    }

    // 11. Cr√©er quelques policies de base
    console.log('\nüõ°Ô∏è Cr√©ation policies RLS de base...');

    try {
      // Users peuvent voir leurs propres donn√©es
      await client.query(`
        CREATE POLICY "Users own timesheet data" ON timesheets 
        FOR ALL TO authenticated 
        USING (user_id = auth.uid()::text);

        CREATE POLICY "Users own timesheet entries" ON timesheet_entries 
        FOR ALL TO authenticated 
        USING (user_id = auth.uid()::text);

        CREATE POLICY "Users own expenses" ON expenses 
        FOR ALL TO authenticated 
        USING (user_id = auth.uid()::text);

        CREATE POLICY "Users own payroll profile" ON user_profile_payroll 
        FOR ALL TO authenticated 
        USING (user_id = auth.uid()::text);
      `);
      console.log('  ‚úÖ Policies de base cr√©√©es');
    } catch (err) {
      console.log(`  ‚ö™ Policies: ${err.message.includes('already exists') ? 'existent d√©j√†' : err.message}`);
    }

    // 12. V√©rification finale
    console.log('\nüîç V√©rification finale...');
    
    const functionsCheck = await client.query(`
      SELECT routine_name 
      FROM information_schema.routines 
      WHERE routine_schema = 'public' 
      AND routine_type = 'FUNCTION'
      AND routine_name IN (
        'calculate_overtime_hours', 'apply_per_diem_rules', 
        'user_has_permission', 'update_stock_after_transaction'
      )
      ORDER BY routine_name
    `);
    
    console.log('üìã Fonctions utilitaires cr√©√©es:');
    functionsCheck.rows.forEach(row => {
      console.log(`  ‚úÖ ${row.routine_name}`);
    });

    const triggersCheck = await client.query(`
      SELECT trigger_name, event_object_table
      FROM information_schema.triggers 
      WHERE trigger_schema = 'public'
      AND trigger_name LIKE 'update_%_updated_at'
      ORDER BY event_object_table
    `);
    
    console.log('üìã Triggers automatiques cr√©√©s:');
    triggersCheck.rows.forEach(row => {
      console.log(`  ‚úÖ ${row.trigger_name} sur ${row.event_object_table}`);
    });

    console.log('\nüéâ FONCTIONS & TRIGGERS TERMIN√âS!');
    console.log('üîß Fonctions utilitaires op√©rationnelles');
    console.log('‚ö° Triggers automatiques actifs');  
    console.log('üîí Row Level Security configur√©');
    console.log('‚è∞ Per diem automatique activ√©');
    console.log('üìä Calculs overtime op√©rationnels');

  } catch (error) {
    console.error('üí• Erreur g√©n√©rale fonctions/triggers:', error);
  } finally {
    await client.end();
    console.log('üîå Connexion ferm√©e');
  }
}

// Ex√©cuter la cr√©ation des fonctions et triggers
createFunctionsAndTriggers();